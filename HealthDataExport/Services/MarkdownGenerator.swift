import Foundation

struct MarkdownGenerator {
    static func generate(
        summaries: [HealthDataSummary],
        dates: [Date]
    ) -> String {
        var markdown = ""

        // Header
        markdown += "# Health Data Export\n\n"
        markdown += "**Export Date**: \(formatDate(Date()))\n\n"
        markdown += "**Data for**: \(formatDateList(dates))\n\n"

        // Summary section
        markdown += "## Summary\n\n"
        for summary in summaries {
            let icon = summary.metricType.icon
            markdown += "- **\(summary.metricType.displayName)**: \(summary.formattedSummary)\n"
        }
        markdown += "\n"

        // Detailed sections for each metric
        markdown += "## Detailed Data\n\n"
        for summary in summaries {
            markdown += "### \(summary.metricType.displayName)\n\n"

            if summary.dataPoints.isEmpty {
                markdown += "*No data available*\n\n"
                continue
            }

            // Show statistics
            if let total = summary.total, summary.metricType != .heartRate && summary.metricType != .weight && summary.metricType != .bodyMassIndex {
                markdown += "**Total**: \(formatValue(total, for: summary.metricType))\n\n"
            }

            if let avg = summary.average {
                markdown += "**Average**: \(formatValue(avg, for: summary.metricType))\n\n"
            }

            if let min = summary.minimum, let max = summary.maximum,
               summary.metricType == .heartRate {
                markdown += "**Range**: \(formatValue(min, for: summary.metricType)) - \(formatValue(max, for: summary.metricType))\n\n"
            }

            // Daily breakdown for multi-day exports
            if dates.count > 1 {
                markdown += "**Daily Breakdown**:\n\n"
                let groupedByDate = Dictionary(grouping: summary.dataPoints) { point in
                    Calendar.current.startOfDay(for: point.date)
                }

                for date in dates.sorted() {
                    let startOfDay = Calendar.current.startOfDay(for: date)
                    if let pointsForDate = groupedByDate[startOfDay], !pointsForDate.isEmpty {
                        let dayTotal = pointsForDate.map { $0.value }.reduce(0, +)
                        markdown += "- \(formatDate(date)): \(formatValue(dayTotal, for: summary.metricType))\n"
                    } else {
                        markdown += "- \(formatDate(date)): No data\n"
                    }
                }
                markdown += "\n"
            }
        }

        // Footer
        markdown += "---\n\n"
        markdown += "*Generated by HealthDataExport*\n"

        return markdown
    }

    private static func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .none
        return formatter.string(from: date)
    }

    private static func formatDateList(_ dates: [Date]) -> String {
        if dates.count == 1 {
            return formatDate(dates[0])
        } else {
            let sorted = dates.sorted()
            return "\(formatDate(sorted.first!)) - \(formatDate(sorted.last!))"
        }
    }

    private static func formatValue(_ value: Double, for type: HealthMetricType) -> String {
        switch type {
        case .steps:
            return "\(Int(value)) steps"
        case .heartRate:
            return String(format: "%.0f bpm", value)
        case .sleep:
            let hours = Int(value)
            let minutes = Int((value - Double(hours)) * 60)
            return "\(hours)h \(minutes)m"
        case .activeEnergy:
            return String(format: "%.1f kcal", value)
        case .exerciseTime:
            return "\(Int(value)) min"
        case .weight:
            return String(format: "%.1f lbs", value)
        case .bodyMassIndex:
            return String(format: "%.1f", value)
        }
    }
}
